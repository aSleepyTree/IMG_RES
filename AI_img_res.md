<div align='center' ><font size='6'>人工智能导论图像恢复大作业 </font></div>


<div align='center' ><font size='5'>PB19061348邹振 </font></div>

#实验环境
----
<font size='3'>python 3.10.2 </font>

<font size='3'>opencv 4.5.5</font>

<font size='3'>numpy 1.22.3</font>

<font size='3'>sklearn 1.0.2</font>

代码中其他导入的库或没用到，或版本不影响
#代码结构

----

- `norm`函数用于图象间范数结果输出
- `noise_mask_image`函数用于生成受损图像，默认按照RGB通道每行噪声比例为0.8,0.4,0.6来生成噪点
- `restore_image`函数用于图像恢复，也是程序的主题部分。
函数主要分为三块分别为：
	1. 均值去噪、即确定噪点后以周围区域内非噪点的平均值赋值于该噪点
	2. 以均值去噪后的图像为基础进一步进行线性回归操作，对在第一步中已经确定的噪点位置的矩形邻域内的所有值进行回归操作（**将已经进行均值去噪的噪点也计入样本集**），然后对噪点位置的值进行预测并对均值去噪后的结果重新赋值
	3. 区域二元线性回归模型，对确定的噪点以其周围矩形区域的非该噪点为样本集对噪点值进行预测，之后直接对其进行预测值覆盖
	
代码运行开始后会进入读条界面，因为进行了三次回复，故读条一共会读三次，如果觉得时间太长目录中也给出了我自己以<strong>test.jpg</strong>图测试的结果，整个运行过程使用了几分钟，具体见下面的测试结果模块
#测试结果

------

压缩包中给出了三个test图像分别为
>test_l
>
![](C:\Users\86187\Desktop\img_res\test_l.jpg)

>test
>
![](C:\Users\86187\Desktop\img_res\test.jpg)

>test_s
>
![](C:\Users\86187\Desktop\img_res\test_s.jpg)

三张图片分辨率不同，测试耗时也不同。另外四张图片是在以 **test.jpg** 为输入的情况下得到的受损图像`test_noise.jpg`，方法1、2、3处理的结果分别为`average.jpg`、`test_restore_Ave_Reg.jpg`、`test_restore_Reg.jpg`  <strong>图片例</strong> 图像中给出了测试过程中以 <strong>test\_l.jpg</strong>  为例做出的结果

![](C:\Users\86187\Desktop\img_res\example.png)<img src="" width="30%" height="30%">

其中倒数第五行输出为三种方法花费时间(单位为秒)，最后四行为各种方法结果与原图差的二范数，受损图像与原图差值的二范数为47172，均值去噪的结果为6998，均值去噪再线性回归的结果为7218，线性回归结果为7058。可以看出均值去噪和线性回归方法二者相比之下，线性回归的效果与均值去噪相差不多*（当然这和我们选择的以二范数作为度量的方法也有关，可能在其他的度量选择中上述优势会发生变化）*，事实上这种差距在人眼看来几乎不存在（我们几乎看不出来`average.jpg`和`test_restore_Reg.jpg`的区别），二者同时使用时的效果稍差（从二范数值看出，但这种思路只是我灵光一现写的，效果不好也在情理之中）；但就耗时而言均值去噪由于计算的简洁耗时较少，同时由于运算过程调用了一些python的库，代码的运行速度是不如自己手写线性回归公式来的快，除此之外我觉得如果用MATLAB这种精于运算的软件的话可能速度还会快很多。
#实验收获

-------

线性回归模型作为一种简单易行的方法是解决很多实际问题时第一个尝试，本例中我们也看到在图像去噪问题中这种方法也能发挥作用，然而由于图像中很多时候并不符合线性模型，该方法在图像处理中仍有局限性。但作为一种学习示例是完全足够的，本例中的对图像逐像素添加噪声和对区域线性回归的操作让我第一次感受到技术和我们的距离很近，用课堂上学到的知识解决实际问题的感觉总是美妙的